---
layout: post
category : 日记
tags : [日记]
---
今天线上又遇到问题了，待在主系统这种组的好处就是永远都有处理不完的问题，哈哈，适合我这种优化狂人。

今天的问题是线上的几台amq服务器经常有load告警，没事申请了权限上去看了下。用sar -r看了眼load，平均load不高，sar -w一看就感觉有点蹊跷了，系统会周期性的有段时间proc特别多，差不多小时为周期，平时proc大概也就不到1，到那个时间段就是十几。正好赶上一波周期到了，用top看了下是amq的进程干的，基本吃掉了4核服务器的全部CPU。看了眼gc.log，没有full gc啊，看来不是被full gc吃掉的。jstack看看呗，一抓下来就下了一大跳，这么多的线程在run着呢，一眼看不到头。用cat /proce/<pid>/status看了眼，好嘛，有3w+的线程，吃了35G+的虚拟内存。不管啥问题，这么多个线程就够喝一壶的了。看线程的名称，都是topic命名的，应该是amq为每个topic创建了一个线程，然后topic中有没有消费掉的消息，就导致线程一直留存在那里。至于为什么会有这么多个topic，就要从遗留的业务设计说起。

消息的生产者生产出消息之后连同自己的ID扔到了queue中，消费者从queue中取出消息进行处理，会给生产者回一个消息，回的消息需要保证被这个消息的生产者自己处理掉。因此当时的解决办法就是用“固定的prefix+生产者ID”作为topic名称生成一个topic，让每个生产者自己去找自己的topic去消费。这个模型本身是比较理想的，现在的问题是不知道什么原因，这些response的消息没有被消费点，然后因为ID本身是不重复的，导致日积月累出现了海量的topic…………

现在就有两个问题要解决：
1. 找到周期性load高的原因，这个猜测是amq自己做消息的清理之类的事情造成的，应该不难查
2. 找到为什么这么多遗留topic中的消息没有被消费掉。这个就比较费劲了……看来要滤一遍代码了


PS:今天在组里夸下海口，给大家分享一下系统分析的工具，题目先想好了，就叫《从手术刀到原子弹》吧 :D 
